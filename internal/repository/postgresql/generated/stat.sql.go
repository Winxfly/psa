// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: stat.sql

package postgresql

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const getLatestStatByProfessionID = `-- name: GetLatestStatByProfessionID :one
SELECT profession_id, vacancy_count, scraped_at_id
FROM stat
WHERE profession_id = $1
ORDER BY scraped_at_id DESC LIMIT 1
`

type GetLatestStatByProfessionIDRow struct {
	ProfessionID uuid.UUID `json:"profession_id"`
	VacancyCount int32     `json:"vacancy_count"`
	ScrapedAtID  uuid.UUID `json:"scraped_at_id"`
}

func (q *Queries) GetLatestStatByProfessionID(ctx context.Context, professionID uuid.UUID) (GetLatestStatByProfessionIDRow, error) {
	row := q.db.QueryRow(ctx, getLatestStatByProfessionID, professionID)
	var i GetLatestStatByProfessionIDRow
	err := row.Scan(&i.ProfessionID, &i.VacancyCount, &i.ScrapedAtID)
	return i, err
}

const getStatsByProfessionsAndDateRange = `-- name: GetStatsByProfessionsAndDateRange :many
SELECT profession_id, vacancy_count, scraped_at_id
FROM stat
         JOIN scraping sc ON stat.scraped_at_id = sc.id
WHERE profession_id = ANY ($1::uuid[])
  AND sc.scraped_at BETWEEN $2 AND $3
ORDER BY profession_id, sc.scraped_at
`

type GetStatsByProfessionsAndDateRangeParams struct {
	Column1     []uuid.UUID `json:"column_1"`
	ScrapedAt   time.Time   `json:"scraped_at"`
	ScrapedAt_2 time.Time   `json:"scraped_at_2"`
}

type GetStatsByProfessionsAndDateRangeRow struct {
	ProfessionID uuid.UUID `json:"profession_id"`
	VacancyCount int32     `json:"vacancy_count"`
	ScrapedAtID  uuid.UUID `json:"scraped_at_id"`
}

func (q *Queries) GetStatsByProfessionsAndDateRange(ctx context.Context, arg GetStatsByProfessionsAndDateRangeParams) ([]GetStatsByProfessionsAndDateRangeRow, error) {
	rows, err := q.db.Query(ctx, getStatsByProfessionsAndDateRange, arg.Column1, arg.ScrapedAt, arg.ScrapedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetStatsByProfessionsAndDateRangeRow
	for rows.Next() {
		var i GetStatsByProfessionsAndDateRangeRow
		if err := rows.Scan(&i.ProfessionID, &i.VacancyCount, &i.ScrapedAtID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertStat = `-- name: InsertStat :one
INSERT INTO stat (profession_id, vacancy_count, scraped_at_id)
VALUES ($1, $2, $3) RETURNING id
`

type InsertStatParams struct {
	ProfessionID uuid.UUID `json:"profession_id"`
	VacancyCount int32     `json:"vacancy_count"`
	ScrapedAtID  uuid.UUID `json:"scraped_at_id"`
}

func (q *Queries) InsertStat(ctx context.Context, arg InsertStatParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, insertStat, arg.ProfessionID, arg.VacancyCount, arg.ScrapedAtID)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}
